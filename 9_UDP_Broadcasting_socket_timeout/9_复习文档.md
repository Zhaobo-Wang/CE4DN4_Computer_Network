### UDP套接字基本概念

* 在TCP中，必须先建立连接，然后才能进行数据通信。因此，当数据到达套接字时，发送者的身份已经建立。同样，当数据通过套接字发送时，目的地也已经被确定。
* 在UDP中，情况不同，因为UDP没有所谓的连接。每个消息都作为单个UDP数据包发送。因此，每当新的UDP数据包到达时，套接字接口必须识别发送者（IP地址和端口）。同样，每当UDP数据包被发送时，也必须识别目的地（IP地址和端口）。

### Python中的UDP套接字

* ```
  创建IPv4/UDP套接字：
  
  s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
  ```

* ```
  从UDP套接字接收最多buffersize字节的数据。此函数返回接收到的数据和远程地址/端口。例如：
  
  output = s.recvfrom(buffersize) 
  msg_bytes, address_port = output 
  address, port = address_port
  ```

* 如果指定的buffersize小于到达的UDP数据包有效载荷长度，则剩余字节将被丢弃！

* ```
  通过指定的地址发送数据（UDP）：要发送的字节和地址/端口传递给函数。例如：
  
  address_port = ("192.168.1.10", 20000) 
  s.sendto(msg_bytes, address_port)
  ```



## UDP和 TCP 在选择上的区别

UDP（用户数据报协议）和 TCP（传输控制协议）是互联网协议套件中的两个主要传输协议，它们在套接字编程中有着显著的不同：

1. **连接性**:
   
   - **TCP**: 是一种面向连接的协议。在数据传输之前，必须在发送方和接收方之间建立连接。这保证了两个端点之间建立了稳定的通信通道。
   - **UDP**: 是一种无连接的协议。数据可以在没有预先建立连接的情况下发送，意味着数据的发送和接收更加简单和快速。

2. **可靠性**:
   
   - **TCP**: 提供可靠的服务。它通过使用序号、确认应答、重传机制等来确保数据正确、完整地到达接收方。
   - **UDP**: 不保证数据的可靠传输。数据包可能会丢失、重复或乱序到达，且UDP本身不提供错误恢复功能。

3. **数据流**:
   
   - **TCP**: 基于字节流，发送的是一个连续的数据流，保证了数据包的顺序。
   - **UDP**: 基于数据报，每个UDP包都是独立的，发送之间互不依赖，也不保证顺序。

4. **速度和效率**:
   
   - **TCP**: 由于其可靠性和连接性，比UDP慢。连接建立、错误检查和恢复机制都增加了延迟和处理时间。
   - **UDP**: 由于其无连接和非可靠性，处理速度比TCP快。它适用于对实时性要求高的应用，如视频流、在线游戏等。

5. **头部开销**:
   
   - **TCP**: 有更大的头部开销（通常20字节或更多），因为它需要携带更多的信息来保证数据传输的可靠性。
   - **UDP**: 头部开销较小（通常8字节），使得数据包更轻量。

6. **使用场景**:
   
   - **TCP**: 适用于需要高可靠性的应用，如网页浏览、文件传输、电子邮件等。
   - **UDP**: 适用于速度和效率更重要的应用，或可以容忍一定丢包的应用，如流媒体、在线游戏、VoIP（语音通信）等。

在套接字编程中，选择TCP还是UDP取决于应用程序的具体需求和预期的通信特性。



### Python Socket Timeout 使用方法和概念

这个文档介绍了在Python中使用套接字超时的概念和应用方法。

1. **套接字超时的重要性**：
   
   - 在某些情况下，对套接字活动设置超时是非常有用的。如果在超时期限内没有发生任何活动，Python脚本会重新获得执行权，并继续进行其他活动。

2. **应用实例**：
   
   - 文档提到了一个应用实例，即在实验3中，客户端主机进行服务发现扫描，以找出特定UDP端口上可用的文件共享服务。
   - 客户端发送IP广播数据包并执行套接字接收，等待一定的超时时间内的响应。如果没有服务器可用，套接字接收会超时，客户端可以重新获得控制并打印出“No servers found.”消息。
   - 没有套接字超时的话，接收操作将会无限期地阻塞。

3. **设置套接字超时**：
   
   - 可以通过`my_socket.settimeout(5)`这样的代码设置套接字的超时值，比如在这里将超时值设置为5秒。如果给定None作为参数，则会禁用超时。

4. **超时异常的处理**：
   
   - 超时异常可以通过try/except块捕获。文档提供了一个示例，其中在尝试接收数据时使用了超时设置，如果发生超时，则会捕获超时异常并打印“Socket recv timeout ...”。

5. **相关文件**：
   
   - 文档提到了一些相关的Python脚本文件，例如`echo_server_timeout.py`, `echo_server_timeout_multiclient.py`, `service_announcement_discovery.py` 和 `file_download_protocol.py`，这些文件可能包含套接字超时功能的实现示例。

通过设置超时，开发者可以避免程序在等待套接字操作时无限期地阻塞，从而增加程序的健壮性和用户体验。

### 

### 设置timeout和不设置timeout的区别

### 设置timeout（设置超时时间）

1. **非阻塞行为**：当为套接字设置了超时时间后，如果在指定的时间内没有发生预期的事件（例如，接收数据或建立连接），套接字操作会因为超时而中断，并抛出一个异常。这意味着程序不会无限期地等待一个事件的发生，从而避免了程序陷入长时间的停顿。

2. **异常处理**：设置超时后，需要在代码中处理可能的超时异常（例如，`socket.timeout`）。这提供了一个机会来执行清理操作，重新尝试操作，或者优雅地关闭连接。

3. **适用场景**：超时设置非常适合那些需要快速响应的应用，例如实时系统、游戏或者需要维持用户界面响应性的客户端应用。

### 不设置timeout（无超时时间）

1. **阻塞行为**：默认情况下，套接字操作是阻塞的。这意味着如果一个操作（如接收数据）开始执行，它将一直等待直到有数据到来，无论需要多长时间。在数据到达或连接建立之前，程序将停在那里不前。

2. **无需异常处理**：因为不会发生超时，所以也就不需要在代码中处理超时异常。但是，这也意味着如果对端没有发送数据或响应，您的程序可能会无限期地挂起。

3. **适用场景**：不设置超时更适合那些不需要快速响应，或者可以容忍长时间等待的应用，例如一些后台数据处理服务或对响应时间要求不高的应用。

总的来说，设置超时是一种控制资源和提高程序响应能力的方法，特别是在需要及时响应的网络通信中。而不设置超时则允许程序无限期等待，这在某些场景下可能是必需的，但也可能导致程序挂起或资源浪费。选择是否设置超时，应根据应用的具体需求和行为特征来决定。



### 广播的概念和实现方式

1. **广播的效率问题**：
   
   * 当数据包需要发送给多个接收者时，一对一通信变得低效。这是因为每个消息必须单独发送给每个接收方，而不是一次性发送给所有人。

2. **网络复制的两种类型**：
   
   * **广播（Broadcast）**：所有网络上的主机都会收到数据包/消息的副本。
   * **多播（Multicast）**：只有所有主机中的一部分子集会收到数据包/消息的副本。
   * 文档中主要讨论了广播的情况，而多播将在后续讨论。

3. **IP广播**：
   
   * **本地IP广播地址**（255.255.255.255）：发送数据包给本地网络上的每个主机。注意，路由器不会转发这些数据包。
   * **定向广播**：通过将主机ID位设置为全部一，可以对特定网络上的所有主机进行广播，例如，使用子网掩码255.255.255.0的网络的定向广播地址为192.168.1.255。
   * 指出互联网范围的广播不被允许，因为它可能会被轻易滥用。

4. **实现IP广播**：
   
   * 设置UDP套接字进行广播：创建一个UDP套接字并设置广播选项（`sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)`），以允许发送广播。
   * 发送到广播地址或定向广播地址及其UDP端口，例如发送消息到 "255.255.255.255" 的端口20000。
   * 注意，接收广播的接收方必须在约定的端口上使用UDP监听，并通常应该绑定到 "0.0.0.0"。

文档还提到了一个示例代码 `broadcast_send_receive.py`，可能用于展示如何在Python中发送和接收广播数据。


